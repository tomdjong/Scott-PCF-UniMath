<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
	<script src="http://code.jquery.com/jquery-1.11.0.min.js" type="text/javascript"></script>
	<script src="./proofs-toggle.js" type="text/javascript"></script>
	<style>
		div.proofcomment {
			font-style: italic;
		}
	</style>
	<title>Documentation</title>
</head>
<body>
<div id="page">
<div id="main">
<h1 class="libtitle">Library UniMath.Algebra.IteratedBinaryOperations</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Combinatorics.Lists</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Combinatorics.FiniteSequences</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Algebra.RigsAndRings</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Foundations.UnivalenceAxiom</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.MoreFoundations.Tactics</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Algebra.Groups</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.MoreFoundations.NegativePropositions</span>.<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Notation</span> "[]" := <span class="id" title="var">Lists.nil</span> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[]").<br/>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Infix</span> "::" := <span class="id" title="var">cons</span>.<br/>

<br/>
</div>

<div class="doc">
general associativity for binary operations on types 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">BinaryOperations</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">X</span>:<span class="id" title="var">UU</span>} (<span class="id" title="var">unel</span>:<span class="id" title="var">X</span>) (<span class="id" title="var">op</span>:<span class="id" title="var">binop</span> <span class="id" title="var">X</span>).<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_list</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">foldr1</span> <span class="id" title="var">op</span> <span class="id" title="var">unel</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">X</span>) : <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exact</span> <span class="id" title="var">unel</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">I</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exact</span> (<span class="id" title="var">op</span> (<span class="id" title="var">I</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>)) (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>)). }}<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_seq</span> : <span class="id" title="var">Sequence</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_fun</span> <span class="id" title="var">x</span>).<br/>
</div>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_list_list</span> : <span class="id" title="var">list</span>(<span class="id" title="var">list</span> <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_list</span> (<span class="id" title="var">map</span> <span class="id" title="var">iterop_list</span> <span class="id" title="var">w</span>)).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun_fun</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">m</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">nat</span>} : (∏ <span class="id" title="var">i</span> (<span class="id" title="var">j</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">m</span> <span class="id" title="var">i</span>)), <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_fun</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">iterop_fun</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>))).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_seq_seq</span> : <span class="id" title="var">Sequence</span> (<span class="id" title="var">Sequence</span> <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_fun_fun</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span>, <span class="id" title="var">x</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span>)).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_list</span> := ∏ (<span class="id" title="var">x</span>:<span class="id" title="var">list</span> (<span class="id" title="var">list</span> <span class="id" title="var">X</span>)), <span class="id" title="var">iterop_list</span> (<span class="id" title="var">Lists.flatten</span> <span class="id" title="var">x</span>) = <span class="id" title="var">iterop_list_list</span> <span class="id" title="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_fun</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∏ <span class="id" title="var">n</span> (<span class="id" title="var">m</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">nat</span>) (<span class="id" title="var">x</span> : ∏ <span class="id" title="var">i</span> (<span class="id" title="var">j</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">m</span> <span class="id" title="var">i</span>)), <span class="id" title="var">X</span>), <span class="id" title="var">iterop_fun</span> (<span class="id" title="var">StandardFiniteSets.flatten'</span> <span class="id" title="var">x</span>) = <span class="id" title="var">iterop_fun_fun</span> <span class="id" title="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_seq</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∏ (<span class="id" title="var">x</span> : <span class="id" title="var">Sequence</span> (<span class="id" title="var">Sequence</span> <span class="id" title="var">X</span>)), <span class="id" title="var">iterop_seq</span> (<span class="id" title="var">FiniteSequences.flatten</span> <span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_seq</span> <span class="id" title="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">stn</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isCommutative_fun</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∏ <span class="id" title="var">n</span> (<span class="id" title="var">x</span>:⟦<span class="id" title="var">n</span>⟧ -&gt; <span class="id" title="var">X</span>) (<span class="id" title="var">f</span>:⟦<span class="id" title="var">n</span>⟧≃⟦<span class="id" title="var">n</span>⟧), <span class="id" title="var">iterop_fun</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">f</span>) = <span class="id" title="var">iterop_fun</span> <span class="id" title="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">assoc_fun_to_seq</span> : <span class="id" title="var">isAssociative_fun</span> -&gt; <span class="id" title="var">isAssociative_seq</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">assoc</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">assoc</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span>, <span class="id" title="var">x</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span>)).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">assoc_seq_to_fun</span> : <span class="id" title="var">isAssociative_seq</span> -&gt; <span class="id" title="var">isAssociative_fun</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">assoc</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">assoc</span> (<span class="id" title="var">functionToSequence</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">functionToSequence</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>)))).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_list_step</span> (<span class="id" title="var">runax</span> : <span class="id" title="var">isrunit</span> <span class="id" title="var">op</span> <span class="id" title="var">unel</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>) (<span class="id" title="var">xs</span>:<span class="id" title="var">list</span> <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_list</span> (<span class="id" title="var">x</span>::<span class="id" title="var">xs</span>) = <span class="id" title="var">op</span> <span class="id" title="var">x</span> (<span class="id" title="var">iterop_list</span> <span class="id" title="var">xs</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">list_ind</span> (<span class="id" title="var">λ</span> <span class="id" title="var">xs</span>, ∏ <span class="id" title="var">x</span> : <span class="id" title="var">X</span>, <span class="id" title="var">iterop_list</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">xs</span>) = <span class="id" title="var">op</span> <span class="id" title="var">x</span> (<span class="id" title="var">iterop_list</span> <span class="id" title="var">xs</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>,<span class="id" title="var">runax</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span> <span class="id" title="var">rest</span> <span class="id" title="var">IH</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun_step'</span> (<span class="id" title="var">lunax</span> : <span class="id" title="var">islunit</span> <span class="id" title="var">op</span> <span class="id" title="var">unel</span>) {<span class="id" title="var">m</span>} (<span class="id" title="var">xs</span>:<span class="id" title="var">stn</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">X</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_fun</span> (<span class="id" title="var">append_vec</span> <span class="id" title="var">xs</span> <span class="id" title="var">x</span>) = <span class="id" title="var">op</span> (<span class="id" title="var">iterop_fun</span> <span class="id" title="var">xs</span>) <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_fun</span> <span class="id" title="tactic">at</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_2</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">y</span>, <span class="id" title="var">op</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>)). <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">append_and_drop_fun</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun_step</span> (<span class="id" title="var">lunax</span> : <span class="id" title="var">islunit</span> <span class="id" title="var">op</span> <span class="id" title="var">unel</span>) {<span class="id" title="var">m</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span>(<span class="id" title="var">S</span> <span class="id" title="var">m</span>) -&gt; <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_fun</span> <span class="id" title="var">x</span> = <span class="id" title="var">op</span> (<span class="id" title="var">iterop_fun</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>)) (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_fun</span> <span class="id" title="tactic">at</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>, <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun_append</span> (<span class="id" title="var">lunax</span> : <span class="id" title="var">islunit</span> <span class="id" title="var">op</span> <span class="id" title="var">unel</span>) {<span class="id" title="var">m</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">X</span>) (<span class="id" title="var">y</span>:<span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_fun</span> (<span class="id" title="var">append_vec</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) = <span class="id" title="var">op</span> (<span class="id" title="var">iterop_fun</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_fun_step</span> <span class="id" title="var">lunax</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">x</span>, <span class="id" title="var">op</span> (<span class="id" title="var">iterop_fun</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">BinaryOperations</span>.<br/>

<br/>
</div>

<div class="doc">
general associativity for monoids 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">multmonoid</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Monoids</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">M</span>:<span class="id" title="var">monoid</span>}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">oo</span> := @<span class="id" title="var">op</span> <span class="id" title="var">M</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">uu</span> := <span class="id" title="var">unel</span> <span class="id" title="var">M</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_fun_mon</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">M</span>) : <span class="id" title="var">M</span> := <span class="id" title="var">iterop_fun</span> <span class="id" title="var">uu</span> <span class="id" title="var">oo</span> <span class="id" title="var">x</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_list_mon</span> : <span class="id" title="var">list</span> <span class="id" title="var">M</span> -&gt; <span class="id" title="var">M</span> := <span class="id" title="var">iterop_list</span> <span class="id" title="var">uu</span> <span class="id" title="var">oo</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_seq_mon</span> : <span class="id" title="var">Sequence</span> <span class="id" title="var">M</span> -&gt; <span class="id" title="var">M</span> := <span class="id" title="var">iterop_seq</span> <span class="id" title="var">uu</span> <span class="id" title="var">oo</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_seq_seq_mon</span> : <span class="id" title="var">Sequence</span> (<span class="id" title="var">Sequence</span> <span class="id" title="var">M</span>) -&gt; <span class="id" title="var">M</span> := <span class="id" title="var">iterop_seq_seq</span> <span class="id" title="var">uu</span> <span class="id" title="var">oo</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_list_list_mon</span> : <span class="id" title="var">list</span> (<span class="id" title="var">list</span> <span class="id" title="var">M</span>) -&gt; <span class="id" title="var">M</span> := <span class="id" title="var">iterop_list_list</span> <span class="id" title="var">uu</span> <span class="id" title="var">oo</span>.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_seq_mon_len1</span> (<span class="id" title="var">x</span> : <span class="id" title="var">stn</span> 1 -&gt; <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">functionToSequence</span> <span class="id" title="var">x</span>) = <span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_seq_mon_step</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) -&gt; <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>) * <span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>, <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_list_mon_nil</span> : <span class="id" title="var">iterop_list_mon</span> [] = 1.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_list_mon_step</span> (<span class="id" title="var">x</span>:<span class="id" title="var">M</span>) (<span class="id" title="var">xs</span>:<span class="id" title="var">list</span> <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_list_mon</span> (<span class="id" title="var">x</span>::<span class="id" title="var">xs</span>) = <span class="id" title="var">x</span> * <span class="id" title="var">iterop_list_mon</span> <span class="id" title="var">xs</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_list_step</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">runax</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_list_mon_singleton</span> (<span class="id" title="var">x</span> : <span class="id" title="var">M</span>) : <span class="id" title="var">iterop_list_mon</span> (<span class="id" title="var">x</span>::[]) = <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_seq_mon_append</span> (<span class="id" title="var">x</span>:<span class="id" title="var">Sequence</span> <span class="id" title="var">M</span>) (<span class="id" title="var">m</span>:<span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">append</span> <span class="id" title="var">x</span> <span class="id" title="var">m</span>) = <span class="id" title="var">iterop_seq_mon</span> <span class="id" title="var">x</span> * <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">x</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">n</span> <span class="id" title="var">x</span>] ?. <span class="id" title="tactic">unfold</span> <span class="id" title="var">append</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">iterop_seq_mon_step</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">a</span>, <span class="id" title="var">a</span> * <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">x</span>, <span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">i</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">append_vec_compute_1</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_seq_seq_mon_step</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) -&gt; <span class="id" title="var">Sequence</span> <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iterop_seq_seq_mon</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>) * <span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>,<span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_seq_mon_homot</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">stn</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">x</span> ~ <span class="id" title="var">y</span> -&gt; <span class="id" title="var">iterop_seq_mon</span>(<span class="id" title="var">n</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_mon</span>(<span class="id" title="var">n</span>,,<span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">N</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">h</span>. <span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">iterop_seq_mon_step</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">two_arg_paths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">N</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">funhomot</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">h</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Monoids</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Monoids2</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="var">M</span>:<span class="id" title="var">monoid</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">op</span> := @<span class="id" title="var">op</span> <span class="id" title="var">M</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">unel</span> := <span class="id" title="var">unel</span> <span class="id" title="var">M</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_list_mon</span> := <span class="id" title="var">isAssociative_list</span> <span class="id" title="var">unel</span> <span class="id" title="var">op</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_fun_mon</span> := <span class="id" title="var">isAssociative_fun</span> <span class="id" title="var">unel</span> <span class="id" title="var">op</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociative_seq_mon</span> := <span class="id" title="var">isAssociative_seq</span> <span class="id" title="var">unel</span> <span class="id" title="var">op</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isCommutative_fun_mon</span> := <span class="id" title="var">isCommutative_fun</span> <span class="id" title="var">unel</span> <span class="id" title="var">op</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Monoids2</span>.<br/>

<br/>
</div>

<div class="doc">
The general associativity theorem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_list_mon_concatenate</span> {<span class="id" title="var">M</span> : <span class="id" title="var">monoid</span>} (<span class="id" title="var">l</span> <span class="id" title="var">s</span> : <span class="id" title="var">list</span> <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">iterop_list_mon</span> (<span class="id" title="var">Lists.concatenate</span> <span class="id" title="var">l</span> <span class="id" title="var">s</span>) = <span class="id" title="var">iterop_list_mon</span> <span class="id" title="var">l</span> * <span class="id" title="var">iterop_list_mon</span> <span class="id" title="var">s</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">list_ind</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>, <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> <span class="id" title="var">J</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Lists.concatenateStep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_list_mon</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 (<span class="id" title="var">iterop_list_step</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">runax</span> <span class="id" title="var">M</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">assocax</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">J</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">associativityOfProducts_list</span> (<span class="id" title="var">M</span>:<span class="id" title="var">monoid</span>) : <span class="id" title="var">isAssociative_list</span> (<span class="id" title="var">unel</span> <span class="id" title="var">M</span>) (@<span class="id" title="var">op</span> <span class="id" title="var">M</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
</div>

<div class="doc">
This proof comes from the Associativity theorem,  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">isAssociative_list</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">list_ind</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> <span class="id" title="var">I</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">I</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Lists.flattenStep</span>. <span class="id" title="tactic">refine</span> (<span class="id" title="var">iterop_list_mon_concatenate</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_list_list</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">mapStep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_list_step</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">runax</span> <span class="id" title="var">M</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">x</span>, <span class="id" title="var">_</span> * <span class="id" title="var">x</span>)). <span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">associativityOfProducts_seq</span> (<span class="id" title="var">M</span>:<span class="id" title="var">monoid</span>) : <span class="id" title="var">isAssociative_seq</span> (<span class="id" title="var">unel</span> <span class="id" title="var">M</span>) (@<span class="id" title="var">op</span> <span class="id" title="var">M</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
</div>

<div class="doc">
This proof comes from the Associativity theorem,  
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">isAssociative_seq</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">x</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">IHn</span>].<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">flatten</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">flatten</span> ((<span class="id" title="var">n</span>,,<span class="id" title="var">x</span>): <span class="id" title="var">NonemptySequence</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">flattenStep</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">lastValue</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_seq_seq</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_fun_fun</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_fun_step</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">lunax</span> <span class="id" title="var">M</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_seq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">z</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">m</span> <span class="id" title="var">z</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">IHm</span>].<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">runax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ <span class="id" title="var">IHn</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">concatenate'_r0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> (<span class="id" title="var">two_arg_paths_b</span> (<span class="id" title="var">natplusr0</span> (<span class="id" title="var">stnsum</span> (<span class="id" title="var">length</span> ∘ (<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span>))))). }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">length</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>,, <span class="id" title="var">z</span>)) <span class="id" title="keyword">with</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>). <span class="id" title="tactic">change</span> (<span class="id" title="var">sequenceToFunction</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>,,<span class="id" title="var">z</span>)) <span class="id" title="keyword">with</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_fun_step</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">lunax</span> <span class="id" title="var">M</span>)). <span class="id" title="tactic">rewrite</span> <span class="id" title="var">concatenateStep</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<span class="id" title="var">z</span> <span class="id" title="var">lastelement</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">w</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">assocax</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">append</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Opaque</span> <span class="id" title="var">iterop_fun</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Transparent</span> <span class="id" title="var">iterop_fun</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_fun_append</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">lunax</span> <span class="id" title="var">M</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">u</span>, <span class="id" title="var">u</span>*<span class="id" title="var">w</span>)). <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHm</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHm</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Corollary</span> <span class="id" title="var">associativityOfProducts'</span> {<span class="id" title="var">M</span>:<span class="id" title="var">monoid</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">f</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">nat</span>) (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f</span>) -&gt; <span class="id" title="var">M</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_seq_mon</span> (<span class="id" title="var">partition</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ <span class="id" title="var">associativityOfProducts_seq</span> <span class="id" title="var">M</span> (<span class="id" title="var">partition</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> := <span class="id" title="var">flatten_partition</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_seq_mon_homot</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">L</span>).<br/>
</div>

<br/>
</div>

<div class="doc">
generalized commutativity 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Notation</span> "s □ x" := (<span class="id" title="var">append</span> <span class="id" title="var">s</span> <span class="id" title="var">x</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 64, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">change_lhs</span> <span class="id" title="var">a</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- @<span class="id" title="var">paths</span> ?<span class="id" title="var">T</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; <span class="id" title="tactic">change</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">T</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">T</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span>) <span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">change_rhs</span> <span class="id" title="var">a</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- @<span class="id" title="var">paths</span> ?<span class="id" title="var">T</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; <span class="id" title="tactic">change</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">T</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="keyword">with</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">T</span> <span class="id" title="var">x</span> <span class="id" title="var">a</span>) <span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">stn</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">commutativityOfProducts_helper</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) -&gt; <span class="id" title="var">M</span>) (<span class="id" title="var">j</span>:<span class="id" title="var">stn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) :<br/>
&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">j</span>) * <span class="id" title="var">x</span> <span class="id" title="var">j</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">j</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">j</span> <span class="id" title="var">jlt</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">jle</span> := <span class="id" title="var">natlthsntoleh</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">jlt</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">transport</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">f</span> := <span class="id" title="var">nil</span> □ <span class="id" title="var">j</span> □ <span class="id" title="var">S</span> <span class="id" title="var">O</span> □ <span class="id" title="var">n</span>-<span class="id" title="var">j</span> : <span class="id" title="var">stn</span> 3 -&gt; <span class="id" title="var">nat</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">B</span> : <span class="id" title="var">stnsum</span> <span class="id" title="var">f</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <span class="id" title="var">stnsum</span>, <span class="id" title="var">f</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">unfold</span> <span class="id" title="var">append_vec</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">natplusassoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">natpluscomm</span> 1). <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">natplusassoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">natpluscomm</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> <span class="id" title="var">S</span>). <span class="id" title="tactic">rewrite</span> <span class="id" title="var">natpluscomm</span>. <span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">minusplusnmm</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">r</span> := <span class="id" title="var">weqfibtototal</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">λ</span> <span class="id" title="var">k</span>, <span class="id" title="var">eqweqmap</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">n</span>, <span class="id" title="var">k</span> &lt; <span class="id" title="var">n</span> : <span class="id" title="var">UU</span>) <span class="id" title="var">B</span>) ) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">stn</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f</span>) ≃ <span class="id" title="var">stn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">x'</span> := <span class="id" title="var">x</span> ∘ <span class="id" title="var">r</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">intermediate_path</span> (<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f</span>,, <span class="id" title="var">x'</span>)).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">induction</span> <span class="id" title="var">B</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_seq_mon_homot</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">x'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> ( <span class="id" title="var">invmaponpathsincl</span> <span class="id" title="var">_</span> ( <span class="id" title="var">isinclstntonat</span> <span class="id" title="var">_</span> ) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_seq_mon</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_seq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">associativityOfProducts'</span> <span class="id" title="var">f</span> <span class="id" title="var">x'</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">partition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 3 <span class="id" title="var">iterop_seq_seq_mon_step</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">iterop_seq_seq_mon</span> (0,,<span class="id" title="var">_</span>)) <span class="id" title="keyword">with</span> (<span class="id" title="var">unel</span> <span class="id" title="var">M</span>); <span class="id" title="tactic">rewrite</span> <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span> <span class="id" title="tactic">at</span> 1 2.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">s0</span> := <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span> (<span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span> (@<span class="id" title="var">lastelement</span> 0))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span> <span class="id" title="tactic">at</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">s1</span> := <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span> (@<span class="id" title="var">lastelement</span> 1)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">s2</span> := @<span class="id" title="var">lastelement</span> 2).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">partition'</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">inverse_lexicalEnumeration</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">f</span> <span class="id" title="var">s0</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">j</span>; <span class="id" title="tactic">change</span> (<span class="id" title="var">f</span> <span class="id" title="var">s1</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>); <span class="id" title="tactic">change</span> (<span class="id" title="var">f</span> <span class="id" title="var">s2</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span>-<span class="id" title="var">j</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">nil</span> □ <span class="id" title="var">j</span> □ <span class="id" title="var">n</span>-<span class="id" title="var">j</span> : <span class="id" title="var">stn</span> 2 -&gt; <span class="id" title="var">nat</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">B'</span> : <span class="id" title="var">stnsum</span> <span class="id" title="var">f'</span> = <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <span class="id" title="var">stnsum</span>, <span class="id" title="var">f'</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">unfold</span> <span class="id" title="var">append_vec</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">natpluscomm</span>. <span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">minusplusnmm</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">r'</span> := <span class="id" title="var">weqfibtototal</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">λ</span> <span class="id" title="var">k</span>, <span class="id" title="var">eqweqmap</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">n</span>, <span class="id" title="var">k</span> &lt; <span class="id" title="var">n</span> : <span class="id" title="var">UU</span>) <span class="id" title="var">B'</span>) ) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">stn</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f'</span>) ≃ <span class="id" title="var">stn</span> <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">x''</span> := <span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> (<span class="id" title="var">j</span>,, <span class="id" title="var">jlt</span>) ∘ <span class="id" title="var">r'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">intermediate_path</span> (<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">stnsum</span> <span class="id" title="var">f'</span>,, <span class="id" title="var">x''</span>) * <span class="id" title="var">x</span> (<span class="id" title="var">j</span>,, <span class="id" title="var">jlt</span>)).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> := <span class="id" title="var">iterop_seq_mon_len1</span> (<span class="id" title="var">λ</span> <span class="id" title="var">j0</span> : <span class="id" title="var">stn</span> 1, <span class="id" title="var">x'</span> ((<span class="id" title="var">weqstnsum1</span> <span class="id" title="var">f</span>) (<span class="id" title="var">s1</span>,, <span class="id" title="var">j0</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">functionToSequence</span> <span class="id" title="tactic">in</span> <span class="id" title="var">L</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">L</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">assocax</span>. <span class="id" title="tactic">refine</span> (<span class="id" title="var">transportf</span> (<span class="id" title="var">λ</span> <span class="id" title="var">k</span>, <span class="id" title="var">_</span>*<span class="id" title="var">k</span>=<span class="id" title="var">_</span>) (<span class="id" title="var">commax</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">assocax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">two_arg_paths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ !<span class="id" title="var">associativityOfProducts'</span> <span class="id" title="var">f'</span> <span class="id" title="var">x''</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">partition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">iterop_seq_seq_mon_step</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">iterop_seq_seq_mon</span> (0,,<span class="id" title="var">_</span>)) <span class="id" title="keyword">with</span> (<span class="id" title="var">unel</span> <span class="id" title="var">M</span>); <span class="id" title="tactic">rewrite</span> <span class="id" title="var">lunax</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">two_arg_paths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">set</span> (<span class="id" title="var">s0'</span> := <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span> (@<span class="id" title="var">lastelement</span> 0)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">partition'</span>. <span class="id" title="tactic">change</span> (<span class="id" title="var">f'</span> <span class="id" title="var">s0'</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_seq_mon_homot</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">x'</span>, <span class="id" title="var">x''</span>, <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">subtypeEquality_prop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">change_lhs</span> (<span class="id" title="var">stntonat</span> <span class="id" title="var">_</span> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">dni</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">di</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">stntonat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- <span class="id" title="keyword">context</span> [ <span class="id" title="keyword">match</span> ?<span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span> <span class="id" title="keyword">end</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">c</span>|<span class="id" title="var">c</span>] <span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">fromempty</span>. <span class="id" title="tactic">assert</span> (<span class="id" title="var">P</span> := <span class="id" title="var">c</span> : <span class="id" title="var">i</span> ≥ <span class="id" title="var">j</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">natlthtonegnatgeh</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">stnlt</span> <span class="id" title="var">i</span>) <span class="id" title="var">P</span>). } }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <span class="id" title="var">partition'</span>. <span class="id" title="tactic">change</span> (<span class="id" title="var">f'</span> <span class="id" title="var">lastelement</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span>-<span class="id" title="var">j</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_seq_mon_homot</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">x'</span>, <span class="id" title="var">x''</span>, <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">subtypeEquality_prop</span>. <span class="id" title="var">change_lhs</span> (<span class="id" title="var">j</span>+1+<span class="id" title="var">i</span>). <span class="id" title="tactic">unfold</span> <span class="id" title="var">dni</span>, <span class="id" title="var">di</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">stntonat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- <span class="id" title="keyword">context</span> [ <span class="id" title="keyword">match</span> ?<span class="id" title="var">x</span> <span class="id" title="keyword">with</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span> <span class="id" title="keyword">end</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt; <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">c</span>|<span class="id" title="var">c</span>] <span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">fromempty</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">negnatlthplusnmn</span> <span class="id" title="var">j</span> <span class="id" title="var">i</span> <span class="id" title="var">c</span>). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">change_rhs</span> (1 + (<span class="id" title="var">j</span> + <span class="id" title="var">i</span>)). <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">natplusassoc</span>. <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">natpluscomm</span> <span class="id" title="var">j</span> 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. } } }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">x'</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">subtypeEquality_prop</span>. <span class="id" title="tactic">change</span> (<span class="id" title="var">j</span>+0 = <span class="id" title="var">j</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">natplusr0</span>. }<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">k</span>, <span class="id" title="var">k</span> * <span class="id" title="var">_</span>)). <span class="id" title="tactic">induction</span> (!<span class="id" title="var">B'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">change_rhs</span> (<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,, <span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> (<span class="id" title="var">j</span>,, <span class="id" title="var">jlt</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_seq_mon_homot</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">x''</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> ( <span class="id" title="var">invmaponpathsincl</span> <span class="id" title="var">_</span> ( <span class="id" title="var">isinclstntonat</span> <span class="id" title="var">_</span> ) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. }<br/>
</div>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">commutativityOfProducts</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">M</span>) (<span class="id" title="var">f</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span> ≃ <span class="id" title="var">stn</span> <span class="id" title="var">n</span>) :<br/>
&nbsp;&nbsp;<span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span>) = <span class="id" title="var">iterop_seq_mon</span> (<span class="id" title="var">n</span>,,<span class="id" title="var">x</span>∘<span class="id" title="var">f</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">set</span> (<span class="id" title="var">i</span> := @<span class="id" title="var">lastelement</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">set</span> (<span class="id" title="var">i'</span> := <span class="id" title="var">f</span> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">iterop_seq_mon_step</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">f</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> ((<span class="id" title="var">x</span> ∘ <span class="id" title="var">f</span>) <span class="id" title="var">lastelement</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> <span class="id" title="var">i'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">commutativityOfProducts_helper</span> <span class="id" title="var">x</span> <span class="id" title="var">i'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">k</span>, <span class="id" title="var">k</span>*<span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">weqoncompl_ne</span> <span class="id" title="var">f</span> <span class="id" title="var">i</span> (<span class="id" title="var">stnneq</span> <span class="id" title="var">i</span>) (<span class="id" title="var">stnneq</span> <span class="id" title="var">i'</span>) : <span class="id" title="var">stn_compl</span> <span class="id" title="var">i</span> ≃ <span class="id" title="var">stn_compl</span> <span class="id" title="var">i'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">g</span> := <span class="id" title="var">weqdnicompl</span> <span class="id" title="var">i</span>); <span class="id" title="tactic">set</span> (<span class="id" title="var">g'</span> := <span class="id" title="var">weqdnicompl</span> <span class="id" title="var">i'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">h</span> := (<span class="id" title="var">invweq</span> <span class="id" title="var">g'</span> ∘ <span class="id" title="var">f'</span> ∘ <span class="id" title="var">g</span>)%<span class="id" title="var">weq</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> : <span class="id" title="var">x</span> ∘ <span class="id" title="var">f</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">lastelement</span> ~ <span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">i'</span> ∘ <span class="id" title="var">h</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intro</span> <span class="id" title="var">j</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">invmaponpathsincl</span> <span class="id" title="var">_</span> ( <span class="id" title="var">isinclstntonat</span> <span class="id" title="var">_</span> ) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">h</span>. <span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">weqcomp_to_funcomp_app</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">pr1_invweq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">j</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">j</span> <span class="id" title="var">J</span>]. <span class="id" title="tactic">unfold</span> <span class="id" title="var">g</span>, <span class="id" title="var">i</span>, <span class="id" title="var">f'</span>, <span class="id" title="var">g'</span>, <span class="id" title="var">stntonat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">weqdnicompl_compute</span> <span class="id" title="var">i'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pr1compl_ne</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">homotweqinvweq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">weqoncompl_ne_compute</span> <span class="id" title="var">f</span> <span class="id" title="var">i</span> (<span class="id" title="var">stnneq</span> <span class="id" title="var">i</span>) (<span class="id" title="var">stnneq</span> <span class="id" title="var">i'</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>, <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">subtypeEquality_prop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">stntonat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">weqdnicompl_compute</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IH</span> (<span class="id" title="var">x</span> ∘ <span class="id" title="var">dni</span> <span class="id" title="var">i'</span>) <span class="id" title="var">h</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_seq_mon_homot</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
finite products (or sums) in monoids 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Combinatorics.FiniteSets</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">UniMath.Foundations.NaturalNumbers</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">NatCard</span>.<br/>

<br/>
</div>

<div class="doc">
first a toy warm-up with addition in nat, based on cardinalities of standard finite sets 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nat_plus_associativity</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">m</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">nat</span>} (<span class="id" title="var">k</span>:∏ (<span class="id" title="var">ij</span> : ∑ <span class="id" title="var">i</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">m</span> <span class="id" title="var">i</span>)), <span class="id" title="var">nat</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">stnsum</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">stnsum</span> (<span class="id" title="var">curry</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span>)) = <span class="id" title="var">stnsum</span> (<span class="id" title="var">k</span> ∘ <span class="id" title="var">lexicalEnumeration</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">weqtoeqstn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">intermediate_weq</span> (∑ <span class="id" title="var">i</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">stnsum</span> (<span class="id" title="var">curry</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">invweq</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">weqstnsum1</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">intermediate_weq</span> (∑ <span class="id" title="var">i</span> <span class="id" title="var">j</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">curry</span> <span class="id" title="var">k</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">weqfibtototal</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">invweq</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">weqstnsum1</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">intermediate_weq</span> (∑ <span class="id" title="var">ij</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">k</span> <span class="id" title="var">ij</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exact</span> (<span class="id" title="var">weqtotal2asstol</span> (<span class="id" title="var">stn</span> ∘ <span class="id" title="var">m</span>) (<span class="id" title="var">stn</span> ∘ <span class="id" title="var">k</span>)). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">intermediate_weq</span> (∑ <span class="id" title="var">ij</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">k</span> (<span class="id" title="var">lexicalEnumeration</span> <span class="id" title="var">m</span> <span class="id" title="var">ij</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> (<span class="id" title="var">weqbandf</span> (<span class="id" title="var">inverse_lexicalEnumeration</span> <span class="id" title="var">m</span>)). <span class="id" title="tactic">intro</span> <span class="id" title="var">ij</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">eqweqmap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> <span class="id" title="var">stn</span>), (<span class="id" title="var">maponpaths</span> <span class="id" title="var">k</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>, <span class="id" title="var">homotinvweqweq</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">inverse_lexicalEnumeration</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Corollary</span> <span class="id" title="var">nat_plus_associativity'</span> <span class="id" title="var">n</span> (<span class="id" title="var">m</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">nat</span>) (<span class="id" title="var">k</span>:∏ <span class="id" title="var">i</span>, <span class="id" title="var">stn</span> (<span class="id" title="var">m</span> <span class="id" title="var">i</span>) -&gt; <span class="id" title="var">nat</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">stnsum</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">stnsum</span> (<span class="id" title="var">k</span> <span class="id" title="var">i</span>)) = <span class="id" title="var">stnsum</span> (<span class="id" title="var">uncurry</span> (<span class="id" title="var">Z</span> := <span class="id" title="var">λ</span> <span class="id" title="var">_</span>,<span class="id" title="var">_</span>) <span class="id" title="var">k</span> ∘ <span class="id" title="var">lexicalEnumeration</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof"> <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">nat_plus_associativity</span> (<span class="id" title="var">uncurry</span> <span class="id" title="var">k</span>)). </div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">iterop_fun_nat</span> {<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>} (<span class="id" title="var">x</span>:<span class="id" title="var">stn</span> <span class="id" title="var">n</span>-&gt;<span class="id" title="var">nat</span>) : <span class="id" title="var">iterop_fun</span> 0 <span class="id" title="var">add</span> <span class="id" title="var">x</span> = <span class="id" title="var">stnsum</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">I</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">iterop_fun_step</span> 0 <span class="id" title="var">add</span> <span class="id" title="var">natplusl0</span> <span class="id" title="var">_</span> @ <span class="id" title="var">_</span> @ ! <span class="id" title="var">stnsum_step</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> + <span class="id" title="var">x</span> <span class="id" title="var">lastelement</span>)). <span class="id" title="tactic">apply</span> <span class="id" title="var">I</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">associativityNat</span> : <span class="id" title="var">isAssociative_fun</span> 0 <span class="id" title="var">add</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_fun_fun</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pathsinv0</span>. <span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">iterop_fun_nat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">intermediate_path</span> (<span class="id" title="var">stnsum</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span> : <span class="id" title="var">stn</span> <span class="id" title="var">n</span>, <span class="id" title="var">stnsum</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">iterop_fun_nat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">nat_plus_associativity'</span>.<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">finsum'</span> {<span class="id" title="var">X</span>} (<span class="id" title="var">fin</span> : <span class="id" title="var">isfinite</span> <span class="id" title="var">X</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">fincard</span> (<span class="id" title="var">isfinitetotal2</span> (<span class="id" title="var">stn</span>∘<span class="id" title="var">f</span>) <span class="id" title="var">fin</span> (<span class="id" title="var">λ</span> <span class="id" title="var">i</span>, <span class="id" title="var">isfinitestn</span> (<span class="id" title="var">f</span> <span class="id" title="var">i</span>)))).<br/>
</div>

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatCard</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">MultipleOperation</span> (<span class="id" title="var">X</span>:<span class="id" title="var">UU</span>) : <span class="id" title="var">UU</span> := <span class="id" title="var">UnorderedSequence</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Mult</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">X</span>:<span class="id" title="var">UU</span>} (<span class="id" title="var">op</span> : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">X</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">composeMultipleOperation</span> : <span class="id" title="var">UnorderedSequence</span> (<span class="id" title="var">UnorderedSequence</span> <span class="id" title="var">X</span>) -&gt; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">op</span> (<span class="id" title="var">composeUnorderedSequence</span> <span class="id" title="var">op</span> <span class="id" title="var">s</span>)).<br/>
</div>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">isAssociativeMultipleOperation</span> := ∏ <span class="id" title="var">x</span>, <span class="id" title="var">op</span> (<span class="id" title="var">flattenUnorderedSequence</span> <span class="id" title="var">x</span>) = <span class="id" title="var">composeMultipleOperation</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Mult</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">AssociativeMultipleOperation</span> {<span class="id" title="var">X</span>} := ∑ <span class="id" title="var">op</span>:<span class="id" title="var">MultipleOperation</span> <span class="id" title="var">X</span>, <span class="id" title="var">isAssociativeMultipleOperation</span> <span class="id" title="var">op</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_unoseq_mon</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>} : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">M</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">J</span> <span class="id" title="var">m</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">J</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">I</span> <span class="id" title="var">fin</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">isfinite</span>, <span class="id" title="var">finstruct</span> <span class="id" title="tactic">in</span> <span class="id" title="var">fin</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">squash_to_set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">setproperty</span> <span class="id" title="var">M</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">λ</span> (<span class="id" title="var">g</span> : <span class="id" title="var">finstruct</span> <span class="id" title="var">I</span>), <span class="id" title="var">iterop_fun_mon</span> (<span class="id" title="var">m</span> ∘ <span class="id" title="var">g</span> : <span class="id" title="var">_</span> -&gt; <span class="id" title="var">M</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">fin</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">x</span>]. <span class="id" title="tactic">induction</span> <span class="id" title="var">x'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n'</span> <span class="id" title="var">x'</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">p</span> := <span class="id" title="var">weqtoeqstn</span> (<span class="id" title="var">invweq</span> <span class="id" title="var">x'</span> ∘ <span class="id" title="var">x</span>)%<span class="id" title="var">weq</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">w</span> := <span class="id" title="var">commutativityOfProducts</span> (<span class="id" title="var">m</span> ∘ <span class="id" title="var">x'</span>) (<span class="id" title="var">invweq</span> <span class="id" title="var">x'</span> ∘ <span class="id" title="var">x</span>)%<span class="id" title="var">weq</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ ! <span class="id" title="var">w</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">w</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">iterop_seq_mon</span>, <span class="id" title="var">iterop_fun_mon</span>, <span class="id" title="var">iterop_seq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">weqcomp_to_funcomp</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">i</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>. <span class="id" title="tactic">exact</span> (! <span class="id" title="var">homotweqinvweq</span> <span class="id" title="var">x'</span> (<span class="id" title="var">x</span> <span class="id" title="var">i</span>)).<br/>
</div>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_unoseq_abgr</span> {<span class="id" title="var">G</span>:<span class="id" title="var">abgr</span>} : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">G</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_unoseq_mon</span> (<span class="id" title="var">M</span>:=<span class="id" title="var">G</span>)).<br/>
</div>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sum_unoseq_ring</span> {<span class="id" title="var">R</span>:<span class="id" title="tactic">ring</span>} : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">R</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_unoseq_mon</span> (<span class="id" title="var">M</span>:=<span class="id" title="var">R</span>)).<br/>
</div>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">product_unoseq_ring</span> {<span class="id" title="var">R</span>:<span class="id" title="var">commring</span>} : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">R</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">iterop_unoseq_mon</span> (<span class="id" title="var">M</span>:=<span class="id" title="var">ringmultabmonoid</span> <span class="id" title="var">R</span>)).<br/>
</div>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">iterop_unoseq_unoseq_mon</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>} : <span class="id" title="var">UnorderedSequence</span> (<span class="id" title="var">UnorderedSequence</span> <span class="id" title="var">M</span>) -&gt; <span class="id" title="var">M</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">composeMultipleOperation</span> <span class="id" title="var">iterop_unoseq_mon</span> <span class="id" title="var">s</span>).<br/>
</div>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">abmonoidMultipleOperation</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>} (<span class="id" title="var">op</span> := @<span class="id" title="var">iterop_unoseq_mon</span> <span class="id" title="var">M</span>) : <span class="id" title="var">MultipleOperation</span> <span class="id" title="var">M</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">iterop_unoseq_mon</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">isAssociativeMultipleOperation_abmonoid</span> {<span class="id" title="var">M</span>:<span class="id" title="var">abmonoid</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">isAssociativeMultipleOperation</span> (@<span class="id" title="var">iterop_unoseq_mon</span> <span class="id" title="var">M</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>