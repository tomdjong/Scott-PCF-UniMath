<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
	<script src="http://code.jquery.com/jquery-1.11.0.min.js" type="text/javascript"></script>
	<script src="./proofs-toggle.js" type="text/javascript"></script>
	<style>
		div.proofcomment {
			font-style: italic;
		}
	</style>
	<title>Documentation</title>
</head>
<body>
<div id="page">
<div id="main">
<h1 class="libtitle">Library UniMath.Induction.W.Naturals</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab2243"></a><h2 class="section">Natural numbers</h2>


<div class="paragraph"> </div>

    The natural numbers are a motivating example of W-types, and one of the only
    W-types readily available in UniMath. We show that they are an initial
    algebra for a polynomial functor, and satisfy a few other properties.

<div class="paragraph"> </div>

    Author: Langston Barrett (@siddharthist)
 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Foundations.Preamble</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Foundations.PartA</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Foundations.PartD</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Foundations.UnivalenceAxiom</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.CategoryTheory.Core.Categories</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.CategoryTheory.Core.Functors</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.CategoryTheory.categories.Types</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.CategoryTheory.FunctorAlgebras</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Ktheory.Utilities</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Induction.PolynomialFunctors</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Induction.W.Core</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">UniMath.Induction.W.Fibered</span>.<br/>

<br/>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Notation</span> <span class="id" title="var">ℕ</span> := <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
The signature for the nat functor is (bool, <span class="inlinecode"><a class="idref" href="UniMath.Foundations.Preamble.html#false"><span class="id" title="constructor">false</span></a></span> <span class="inlinecode">↦</span> <span class="inlinecode"><a class="idref" href="UniMath.Foundations.Preamble.html#empty"><span class="id" title="inductive">empty</span></a>;</span> <span class="inlinecode"><a class="idref" href="UniMath.Foundations.Preamble.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode">↦</span> <span class="inlinecode"><a class="idref" href="UniMath.Foundations.Preamble.html#unit"><span class="id" title="inductive">unit</span></a></span>)
    since the naturals have two constructors: one for zero and one for successor.
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_functor</span> : <span class="id" title="var">functor</span> <span class="id" title="var">type_precat</span> <span class="id" title="var">type_precat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">polynomial_functor</span> <span class="id" title="var">bool</span> (<span class="id" title="var">bool_rect</span> (<span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">UU</span>) <span class="id" title="var">empty</span> <span class="id" title="var">unit</span>).<br/>

<br/>
</div>

<div class="doc">
The functor deals with functions from ∅ and unit; these lemmas will come in
    handy in several proofs. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eqfromempty</span> {<span class="id" title="var">X</span> : <span class="id" title="var">UU</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">empty</span> -&gt; <span class="id" title="var">X</span>) : <span class="id" title="var">f</span> = <span class="id" title="var">fromempty</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof"> <span class="id" title="tactic">apply</span> <span class="id" title="var">proofirrelevance</span>, <span class="id" title="var">isapropifcontr</span>, <span class="id" title="var">iscontrfunfromempty</span>. </div>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eta_unit</span> {<span class="id" title="var">X</span> : <span class="id" title="var">UU</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">unit</span> -&gt; <span class="id" title="var">X</span>) : <span class="id" title="var">f</span> = <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">f</span> <span class="id" title="var">tt</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof"> <span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">induction</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">reflexivity</span>. </div>

<br/>
</div>

<div class="doc">
Simplifying the action of the functor on arrows 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_functor_arr_true</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">UU</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Y</span>) <span class="id" title="var">g</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="var">functor_on_morphisms</span> <span class="id" title="var">nat_functor</span>) <span class="id" title="var">f</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">g</span>) = (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">polynomial_functor_arr</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>, <span class="id" title="var">eqfromempty</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_functor_arr_false</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">UU</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Y</span>) <span class="id" title="var">g</span> :<br/>
&nbsp;&nbsp;(<span class="id" title="var">functor_on_morphisms</span> <span class="id" title="var">nat_functor</span>) <span class="id" title="var">f</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">g</span>) = (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">tt</span>)).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">polynomial_functor_arr</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>, <span class="id" title="var">eta_unit</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
Here's how to prove two functions from a nat_functor are equal:
    check both cases. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">from_nat_functor_eq</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">UU</span>} :<br/>
&nbsp;&nbsp;∏ <span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat_functor</span> <span class="id" title="var">X</span> → <span class="id" title="var">Y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>) = <span class="id" title="var">g</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(∏ <span class="id" title="var">h</span>, <span class="id" title="var">f</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">h</span> <span class="id" title="var">tt</span>) = <span class="id" title="var">g</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">h</span> <span class="id" title="var">tt</span>)) -&gt; <span class="id" title="var">f</span> = <span class="id" title="var">g</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> ? <span class="id" title="var">eqfalse</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">pair</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">z</span>, <span class="id" title="var">f</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">z</span>)) (<span class="id" title="var">eqfromempty</span> <span class="id" title="var">bfun</span>) @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ !<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">z</span>, <span class="id" title="var">g</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">z</span>)) (<span class="id" title="var">eqfromempty</span> <span class="id" title="var">bfun</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">eqfalse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">z</span>, <span class="id" title="var">f</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">z</span>)) (<span class="id" title="var">eta_unit</span> <span class="id" title="var">bfun</span>) @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ !<span class="id" title="var">maponpaths</span> (<span class="id" title="var">λ</span> <span class="id" title="var">z</span>, <span class="id" title="var">g</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">z</span>)) (<span class="id" title="var">eta_unit</span> <span class="id" title="var">bfun</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eqfalse</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
The intuition is that an algebra X for this functor is given by a constant
    x : X and a function X → X. The following equivalence verifies this. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_functor_equiv</span> :<br/>
&nbsp;&nbsp;∏ {<span class="id" title="var">X</span> : <span class="id" title="var">UU</span>}, (<span class="id" title="var">X</span> × (<span class="id" title="var">X</span> → <span class="id" title="var">X</span>)) ≃ (<span class="id" title="var">nat_functor</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">use</span> <span class="id" title="var">weq_iso</span>.<br/>
&nbsp;&nbsp;* <span class="id" title="tactic">intros</span> <span class="id" title="var">dprodpair</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pairfun</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">pairfun</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>]; <span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">pr1</span> <span class="id" title="var">dprodpair</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">dprodpair</span> (<span class="id" title="var">bfun</span> <span class="id" title="var">tt</span>)).<br/>
&nbsp;&nbsp;* <span class="id" title="tactic">intro</span> <span class="id" title="var">pairfun</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">dirprodpair</span> (<span class="id" title="var">pairfun</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">λ</span> <span class="id" title="var">x</span>, <span class="id" title="var">pairfun</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;* <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;* <span class="id" title="tactic">intro</span> <span class="id" title="var">Y</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">from_nat_functor_eq</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
Using our equivalence, we can consisely define the algebra corresponding to
    ℕ. Any choice of zero results in an isomorphic algebra.
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_alg</span> (<span class="id" title="var">n</span> : <span class="id" title="var">ℕ</span>) : <span class="id" title="var">algebra_ob</span> <span class="id" title="var">nat_functor</span> :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">ℕ</span>,, <span class="id" title="var">nat_functor_equiv</span> (<span class="id" title="var">dirprodpair</span> <span class="id" title="var">n</span> <span class="id" title="var">S</span>)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_alg_z</span> : <span class="id" title="var">algebra_ob</span> <span class="id" title="var">nat_functor</span> := <span class="id" title="var">nat_alg</span> 0.<br/>

<br/>
</div>

<div class="doc">
We may also define it directly. This will be judgmentally equal
    to <span class="inlinecode"><span class="id" title="var">nat_alg_z</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">nat_alg'</span> : <span class="id" title="var">algebra_ob</span> <span class="id" title="var">nat_functor</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">algebra_ob</span>, <span class="id" title="var">nat_functor</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">polynomial_functor_obj</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ℕ</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">pair</span>, <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">rect</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">rect</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> 0.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">S</span> (<span class="id" title="var">rect</span> <span class="id" title="var">tt</span>)).<br/>
</div>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_algs_eq</span> : <span class="id" title="var">nat_alg_z</span> = <span class="id" title="var">nat_alg'</span>. <a class="proof" href="#">Show proof.</a><br/><div class="proof"> <span class="id" title="tactic">reflexivity</span>. </div>

<br/>
</div>

<div class="doc">
An algebra morphism between algebras for the nat functor is a
    function that respects all the relevant structure. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mk_nat_functor_algebra_mor</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">algebra_ob</span> <span class="id" title="var">nat_functor</span>} :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">X'</span> := <span class="id" title="var">invmap</span> <span class="id" title="var">nat_functor_equiv</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">X</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">Y'</span> := <span class="id" title="var">invmap</span> <span class="id" title="var">nat_functor_equiv</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">Y</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;∏ (<span class="id" title="var">f</span> : <span class="id" title="var">pr1</span> <span class="id" title="var">X</span> → <span class="id" title="var">pr1</span> <span class="id" title="var">Y</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> (<span class="id" title="var">pr1</span> <span class="id" title="var">X'</span>) = (<span class="id" title="var">pr1</span> <span class="id" title="var">Y'</span>)) × (<span class="id" title="var">f</span> ∘ (<span class="id" title="var">pr2</span> <span class="id" title="var">X'</span>) = (<span class="id" title="var">pr2</span> <span class="id" title="var">Y'</span>) ∘ <span class="id" title="var">f</span>)<br/>
&nbsp;&nbsp;→ <span class="id" title="var">is_algebra_mor</span> <span class="id" title="var">_</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">f</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X'</span> <span class="id" title="var">Y'</span> <span class="id" title="var">f</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">from_nat_functor_eq</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">unfold</span> <span class="id" title="var">funcomp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ !<span class="id" title="var">maponpaths</span> <span class="id" title="var">_</span> (<span class="id" title="var">nat_functor_arr_true</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">pr1</span> <span class="id" title="var">p</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">Y</span>)), <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">apply</span> (<span class="id" title="var">eqtohomot</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">p</span>)).<br/>
</div>

<br/>
</div>

<div class="doc">
Define the unique algebra morphism out of ℕ 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_alg_is_preinitial</span> : <span class="id" title="var">is_preinitial</span> <span class="id" title="var">nat_alg_z</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">X</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <span class="id" title="var">pr2</span> <span class="id" title="var">X</span>).<br/>

<br/>
</div>

<div class="doc">
X has a "zero" and a "successor", just like ℕ, given by the algebra
      structure. We use these to define the unique morphism ℕ -&gt; X
      by induction. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">x0</span>    := <span class="id" title="var">x</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">xsucc</span> := (<span class="id" title="var">λ</span> <span class="id" title="var">y</span>, <span class="id" title="var">x</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">y</span>)) : <span class="id" title="var">pr1</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">pr1</span> <span class="id" title="var">X</span>).<br/>

<br/>
</div>

<div class="doc">
The recursor for ℕ gets an extra argument of type ℕ, which we don't pass
      to xsucc. Compare to <span class="inlinecode"><span class="id" title="var">CategoryTheory.FunctorAlgebras.nat_ob_rec</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">nat_rect</span> <span class="id" title="var">_</span> <span class="id" title="var">x0</span> (<span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">xsucc</span>)),, <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">mk_nat_functor_algebra_mor</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
The first projection of the morphism out of ℕ (the actual function)
    is unique. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_alg_func_is_unique</span> :<br/>
&nbsp;&nbsp;∏ <span class="id" title="var">X</span>, ∏ (<span class="id" title="var">mor</span> : <span class="id" title="var">algebra_mor</span> <span class="id" title="var">_</span> <span class="id" title="var">nat_alg_z</span> <span class="id" title="var">X</span>), <span class="id" title="var">pr1</span> <span class="id" title="var">mor</span> = <span class="id" title="var">pr1</span> (<span class="id" title="var">nat_alg_is_preinitial</span> <span class="id" title="var">X</span>).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">mor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">X</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">X</span> <span class="id" title="var">x</span>]; <span class="id" title="tactic">induction</span> <span class="id" title="var">mor</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">mor</span> <span class="id" title="var">is_mor</span>]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">mor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextfun</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">is_algebra_mor</span> <span class="id" title="tactic">in</span> <span class="id" title="var">is_mor</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">mor</span>, <span class="id" title="var">is_mor</span>.<br/>
</div>

<div class="doc">
Use the condition that mor is an algebra morphism 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">eqtohomot</span> <span class="id" title="var">is_mor</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>)) @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_functor_arr_true</span>.<br/>
&nbsp;&nbsp;- </div>

<div class="doc">
Use the condition that mor is an algebra morphism 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">eqtohomot</span> <span class="id" title="var">is_mor</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">_</span>)) @ <span class="id" title="var">_</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">maponpaths</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">polynomial_functor_arr</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">ttt</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">ttt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
Since fibered algebras are the "dependent version" of normal algebras,
    we need some kind of "dependent version" of the lemmas above.
 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">sec_fromempty</span> {<span class="id" title="var">X</span> : <span class="id" title="var">UU</span>} {<span class="id" title="var">Y</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">UU</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span> : ∅ -&gt; <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">t</span> : ∏ <span class="id" title="var">z</span> : ∅, <span class="id" title="var">Y</span> (<span class="id" title="var">f</span> <span class="id" title="var">z</span>)) : <span class="id" title="var">t</span> = <span class="id" title="var">λ</span> <span class="id" title="var">e</span>, <span class="id" title="var">fromempty</span> <span class="id" title="var">e</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">induction</span> <span class="id" title="var">_</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
A fibered algebra over ℕ consists of a family ℕ → UU, a point x0 : X 0,
    and a function from each X n to X (S n).
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fibered_algebra_nat</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">fibered_alg</span> <span class="id" title="var">nat_alg_z</span> ≃ ∑ (<span class="id" title="var">X</span> : ∏ <span class="id" title="var">n</span> : <span class="id" title="var">ℕ</span>, <span class="id" title="var">UU</span>), (<span class="id" title="var">X</span> 0) × (∏ {<span class="id" title="var">n</span>}, <span class="id" title="var">X</span> <span class="id" title="var">n</span> → <span class="id" title="var">X</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">weqfibtototal</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">X</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">use</span> <span class="id" title="var">weq_iso</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">dirprodpair</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>) (<span class="id" title="var">λ</span> <span class="id" title="var">e</span>, <span class="id" title="var">fromempty</span> <span class="id" title="var">e</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (<span class="id" title="var">λ</span> <span class="id" title="var">n</span> <span class="id" title="var">xn</span>, <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">fibered_alg</span> <span class="id" title="tactic">in</span> <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">x</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">n</span>) (<span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">xn</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">fibered_alg</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pair</span> <span class="id" title="var">from</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">pr1</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">x</span> (<span class="id" title="var">bfun</span> <span class="id" title="var">tt</span>) (<span class="id" title="var">from</span> <span class="id" title="var">tt</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="var">cbn</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">pair</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">bfun</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">sec_fromempty</span> <span class="id" title="var">bfun</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">eqfromempty</span> <span class="id" title="var">bfun</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">eta_unit</span> <span class="id" title="var">bfun</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (!<span class="id" title="var">eta_unit</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
A section from ℕ consists of a "point" x : ∏ n, X n such that
    x agrees with the function which is a part of the fibered
    algebra (see above).
 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mk_nat_alg_sec</span> :<br/>
&nbsp;&nbsp;∏ (<span class="id" title="var">FA</span> : <span class="id" title="var">fibered_alg</span> <span class="id" title="var">nat_alg_z</span>),<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">FA'</span> := <span class="id" title="var">fibered_algebra_nat</span> <span class="id" title="var">FA</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">in</span> ∏ (<span class="id" title="var">x</span> : ∏ <span class="id" title="var">n</span> : <span class="id" title="var">ℕ</span>, <span class="id" title="var">pr1</span> <span class="id" title="var">FA'</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p1</span> : <span class="id" title="var">x</span> 0 = <span class="id" title="var">pr1</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">FA'</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p2</span> : (∏ <span class="id" title="var">n</span>, <span class="id" title="var">pr2</span> (<span class="id" title="var">pr2</span> <span class="id" title="var">FA'</span>) <span class="id" title="var">n</span> (<span class="id" title="var">x</span> <span class="id" title="var">n</span>) = <span class="id" title="var">x</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))),<br/>
&nbsp;&nbsp;<span class="id" title="var">algebra_section</span> <span class="id" title="var">FA</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">FA</span> <span class="id" title="var">FA'</span> <span class="id" title="var">x</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">algebra_section</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">x</span>,, <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">pair</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">bfun</span>.<br/>
&nbsp;&nbsp;- </div>

<div class="doc">
They are equal at 0 by hypothesis p1, the rest is noise. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">p1</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">FA'</span>, <span class="id" title="var">fibered_algebra_nat</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">eqfromempty</span> <span class="id" title="var">bfun</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (!<span class="id" title="var">p2</span> (<span class="id" title="var">bfun</span> <span class="id" title="var">tt</span>) @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">eta_unit</span> (<span class="id" title="var">bfun</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
Another way to make an algebra section given different starting data. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mk_nat_alg_sec'</span> {<span class="id" title="var">X</span> : <span class="id" title="var">ℕ</span> -&gt; <span class="id" title="var">UU</span>} {ρ : ∏ <span class="id" title="var">n</span>, <span class="id" title="var">X</span> <span class="id" title="var">n</span> → <span class="id" title="var">X</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> : ∏ <span class="id" title="var">n</span> : <span class="id" title="var">ℕ</span>, <span class="id" title="var">X</span> <span class="id" title="var">n</span>) (<span class="id" title="var">H</span> : ∏ <span class="id" title="var">n</span> : <span class="id" title="var">ℕ</span>, <span class="id" title="var">x</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = ρ <span class="id" title="var">n</span> (<span class="id" title="var">x</span> <span class="id" title="var">n</span>)) :<br/>
&nbsp;&nbsp;<span class="id" title="var">algebra_section</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">invmap</span> <span class="id" title="var">fibered_algebra_nat</span> (<span class="id" title="var">X</span>,, (<span class="id" title="var">x</span> 0,, ρ))).<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">x</span>,, <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pair</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">pair</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">bfun</span>]; <span class="id" title="tactic">induction</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
Define the section out of ℕ, prove it's really a section 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nat_alg_is_preinitial_sec</span> : <span class="id" title="var">is_preinitial_sec</span> <span class="id" title="var">nat_alg_z</span>.<br/>
<a class="proof" href="#">Show proof.</a><br/><div class="proof">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">pose</span> (<span class="id" title="var">x</span> := <span class="id" title="var">pr2</span> <span class="id" title="var">E</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">is_preinitial</span>, <span class="id" title="var">algebra_section</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">use</span> <span class="id" title="var">mk_nat_alg_sec</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">nat_rect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> (<span class="id" title="var">true</span>,, <span class="id" title="var">fromempty</span>) (<span class="id" title="var">empty_rect</span> (<span class="id" title="var">pr1</span> <span class="id" title="var">E</span> ∘ <span class="id" title="var">fromempty</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> ? <span class="id" title="var">fn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">x</span> (<span class="id" title="var">false</span>,, <span class="id" title="var">λ</span> <span class="id" title="var">_</span>, <span class="id" title="var">n</span>) (<span class="id" title="var">λ</span> <span class="id" title="var">b</span> : <span class="id" title="var">unit</span>, <span class="id" title="var">fn</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">maponpaths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">funextsec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
</div>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>